## 总结php反序列化
### 0x01什么是php反序列化
在php中，序列化是将对象转换为字节序列的过程，反序列化则是将字节序列恢复为对象的过程。该过程的意义是可以将一个对象通过可保存的字节方式进行存储，当需要的时候再通过反序列化来获取。
### 0x02类的序列化与反序列化
##### 序列化
我们看一个简单的例子：  
```
<?php
class cls {
	var $value = '123456';
	function do(){
		echo 'do..';
	}
}
$a = new cls();
print_r($a);
print_r(serialize($a));
?>
```
运行结果：  
```
cls Object
(
	[value] => 123456
)
O:3:"cls":1:{s:5:"value";s:6:"123456";}
```
我们可以看到对象被序列化成了字节码，其中保留了类名，以及变量的相关信息，但是并没有函数的相关信息。  
详细解释一下序列化之后的内容：O代表对象，3代表该对象的对象名长度为3，"cls"即对象名，1代表对象中有1个成员变量，随后大括号里面是对这个成员变量的描述，以“变量名;变量值;变量名;变量值;...”的方式来描述。s代表string，即字符串，5代表变量名长度，"value"即变量名，分号代表该变量名描述结束，随后是对变量值的描述，与对变量名的描述形式相同。  
这里有两个特殊的点，如果序列化的对象成员变量为私有，例如cls类有一个私有成员`private $abc = "123";`序列化之后的结果为`s:8:"abc123"`，这里为什么是8呢？是因为序列化的过程中，私有成员除了变量名前加了类名，还有两个不可见字符，即序列化后的结果实际为`s\:8\:"%00abc%00123"`，`%00`为url编码，解码后为不可见字符(有时候会显示成一个空格有时候不显示)，所以结果为8。  
而如果序列化的对象成员是保护类型(即protected)，则序列化后的结果也会有差别，例如cls类有一个保护成员`private $abc = "123";`序列化之后的结果为`s\:5\:"*wa";`这里为什么是5呢？原因就是又生成了两个`%00`不可见字符，即真实结果为`s\:5\:"%00*%00wa";`所以结果为5。  
序列化后的字母标识符主要有O(对象Object)、s(字符串string)、i(整数integer)  
当类中的变量是另一个类时，序列化过程中会将另一个类也进行序列化，例如：  
```
<?php
class cls1{
	function __construct(){
		$this->value = new cls2();
	}
}
class cls2{
	var $king = 'cls2';
}
$a = new cls1();
print_r($a);
print_r(serialize($a));
?>
```
运行结果：  
```
cls1 Object
(
	[value] => cls2 Object
		(
			[king] => cls2
		)
)
O:4:"cls1":1:{s:5:"value";O:4:"cls2":1:{s:4:"king";s:4:"cls2";}}
```
可以看到另一个类也被序列化了。  
##### 反序列化
反序列化会将字节码恢复成对象，看一个例子：  
```
<?php
class aaaaa{
	var $asdf = 1;
	var $apple = "red";
}

$a = 'O:5:"aaaaa":2:{s:4:"asdf";i:1;s:5:"apple";s:3:"red";}';
print_r(unserialize($a));
?>
```
运行结果：
```
aaaaa Object
(
    [asdf] => 1
    [apple] => red
)
```
可以看到字节码被成功恢复成了对象。  
如果我们反序列化一个不存在的类，结果就会显示一个```__PHP_Incomplete_Class Object```:  
```
<?php
$a = 'O:5:"aaaaa":2:{s:4:"asdf";i:1;s:5:"apple";s:3:"red";}';
print_r(unserialize($a));
?>
```
运行结果：  
```
__PHP_Incomplete_Class Object
(
    [__PHP_Incomplete_Class_Name] => aaaaa
    [asdf] => 1
    [apple] => red
)
```
